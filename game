<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>SWATCH Snake & Runner</title>
<style>
  html { scroll-behavior: smooth; }
  body {
    margin: 0; font-family: Arial, sans-serif; color: #111;
    background: linear-gradient(135deg, #ffffff 0%, #fff1f1 45%, #e71d2b 100%);
    min-height: 100vh;
  }
  .corner {
    position: fixed; width: 76px; height: 76px; object-fit: contain;
    opacity: 0.2; pointer-events: none; user-select: none; z-index: 0;
  }
  .corner.tl { top: 10px; left: 10px; }
  .corner.tr { top: 10px; right: 10px; }
  .corner.bl { bottom: 10px; left: 10px; }
  .corner.br { bottom: 10px; right: 10px; }

  .content { position: relative; z-index: 1; }
  .page {
    min-height: 100vh; display: flex; flex-direction: column; align-items: center; gap: 16px;
    padding: 32px 16px 56px;
  }
  .brand {
    display: flex; align-items: center; gap: 12px;
    letter-spacing: 2px; font-weight: 800; font-size: 28px; color: #111;
  }
  .brand .plus {
    display: inline-block; width: 24px; height: 24px; background: #e71d2b; position: relative; border-radius: 4px;
  }
  .brand .plus::before, .brand .plus::after {
    content: ""; position: absolute; background: #fff; left: 50%; top: 50%; transform: translate(-50%,-50%);
  }
  .brand .plus::before { width: 70%; height: 22%; }
  .brand .plus::after  { width: 22%; height: 70%; }

  .hud { display: flex; gap: 12px; align-items: center; justify-content: center; flex-wrap: wrap; }
  .btn {
    padding: 12px 18px; border: none; border-radius: 12px; cursor: pointer;
    background: #1a5bd6; color: #fff; font-weight: 700; box-shadow: 0 3px 10px rgba(0,0,0,0.14);
  }
  .btn:hover { filter: brightness(1.06); }
  .btn-secondary { background: #e71d2b; }
  .stat {
    padding: 8px 12px; border-radius: 10px; background: #fff; color: #333;
    box-shadow: 0 1px 4px rgba(0,0,0,0.08); font-weight: 700; min-width: 110px; text-align: center;
  }

  .frame {
    background: #b31322; border: 8px solid #8a0e1a; border-radius: 16px;
    box-shadow: 0 12px 30px rgba(0,0,0,0.2), inset 0 0 0 1px rgba(255,255,255,0.2);
    position: relative;
  }
  canvas { display: block; touch-action: none; border-radius: 10px; }

  /* Overlay-Karten */
  .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; backdrop-filter: blur(2px); padding: 16px; }
  .card {
    width: 360px; border-radius: 18px; overflow: hidden; box-shadow: 0 18px 40px rgba(0,0,0,0.28);
    background: #ffffff; display: grid; grid-template-rows: auto 84px auto; border: 1px solid rgba(0,0,0,0.06);
  }
  .card-head {
    background: #51c5ff; color: #fff; padding: 18px 20px 12px;
    display: grid; grid-template-columns: 1fr 1fr; align-items: center; text-align: center; gap: 12px;
  }
  .kpi { font-size: 16px; font-weight: 700; display: grid; gap: 4px; justify-items: center; }
  .kpi .icon { font-size: 28px; line-height: 1; }
  .kpi .val { font-size: 22px; }
  .card-mid {
    background: #73d1ff; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 8px; position: relative;
  }
  .snake-preview { width: 280px; height: 36px; background: #ff334d; border-radius: 18px; position: relative; }
  .snake-preview .eye { position: absolute; top: -10px; width: 16px; height: 16px; border-radius: 50%; background: #fff; border: 2px solid #1f1f1f; }
  .snake-preview .eye.left  { left: 210px; }
  .snake-preview .eye.right { left: 232px; }
  .snake-preview .pupil { position: absolute; width: 6px; height: 6px; border-radius: 50%; background: #111; top: 4px; left: 4px; }
  .card-foot { background: repeating-linear-gradient(90deg, #b8d97b 0 24px, #a7cf64 24px 48px); padding: 16px; }
  .card-actions { padding: 16px; display: flex; gap: 12px; justify-content: center; background: #ffffff; }
  .btn-play {
    background: #1a5bd6; color: #fff; font-weight: 800; border: none; border-radius: 12px; padding: 12px 24px; font-size: 16px;
    display: inline-flex; align-items: center; gap: 8px; cursor: pointer; box-shadow: 0 6px 16px rgba(26,91,214,0.35);
  }

  /* Auswahl-Overlay mit zwei Karten */
  .overlay-select { display: none; position: absolute; inset: 0; align-items: center; justify-content: center; padding: 16px; backdrop-filter: blur(2px); }
  .select-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; }
  .pick {
    width: 280px; border-radius: 18px; overflow: hidden; border: 1px solid rgba(0,0,0,0.06);
    background: #fff; box-shadow: 0 12px 32px rgba(0,0,0,0.2); cursor: pointer;
    display: grid; grid-template-rows: 140px auto;
  }
  .pick .head { display: flex; align-items: center; justify-content: center; font-weight: 800; color: #fff; font-size: 18px; }
  .pick.snake .head { background: #ff6b8a; }
  .pick.runner .head { background: #1a5bd6; }
  .pick .body { padding: 14px; text-align: center; color: #333; }
</style>
</head>
<body>
  <!-- Logos -->
  <img class="corner tl" src="swatch-logo.png" alt="Logo">
  <img class="corner tr" src="swatch-logo.png" alt="Logo">
  <img class="corner bl" src="swatch-logo.png" alt="Logo">
  <img class="corner br" src="swatch-logo.png" alt="Logo">

  <div class="content page">
    <div class="brand">SWATCH <span class="plus"></span></div>

    <div class="hud">
      <button id="switchGame" class="btn" title="Spiel wechseln">‚öôÔ∏è</button>
      <button id="restart" class="btn" style="display:none;">Neu starten</button>
      <button id="backToSnake" class="btn btn-secondary" style="display:none;">Zur√ºck zu Snake</button>
      <div class="stat" id="score">Score: 0</div>
      <div class="stat" id="best">Best: 0</div>
    </div>

    <div class="frame">
      <!-- Snake: 10√ó9 Grid: 500√ó450, Zellgr√∂√üe 50 -->
      <canvas id="board" width="500" height="450" aria-label="Spielfeld"></canvas>

      <!-- Spielstart/Resume-Karte -->
      <div id="overlay" class="overlay">
        <div class="card">
          <div class="card-head">
            <div class="kpi">
              <div class="icon">‚åöÔ∏è</div>
              <div>Uhren</div>
              <div class="val" id="kpi-apples">0</div>
            </div>
            <div class="kpi">
              <div class="icon">üèÜ</div>
              <div>Best</div>
              <div class="val" id="kpi-best">0</div>
            </div>
          </div>
          <div class="card-mid">
            <div class="snake-preview">
              <div class="eye left"><div class="pupil"></div></div>
              <div class="eye right"><div class="pupil"></div></div>
            </div>
          </div>
          <div class="card-foot"></div>
          <div class="card-actions">
            <button id="startBtn" class="btn-play">‚ñ∂ Play</button>
          </div>
        </div>
      </div>

      <!-- Auswahl-Overlay -->
      <div id="selectOverlay" class="overlay-select">
        <div class="select-grid">
          <div id="pickSnake" class="pick snake">
            <div class="head">SWATCH Snake</div>
            <div class="body">Rote Schlange, Uhren & Flaggen einsammeln.</div>
          </div>
          <div id="pickRunner" class="pick runner">
            <div class="head">SWATCH Runner</div>
            <div class="body">Hindernisse √ºberspringen, Uhren sammeln.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
  // Pfeiltasten blockieren Scroll
  window.addEventListener('keydown', (e) => {
    const block = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '];
    if (block.includes(e.key)) e.preventDefault();
  }, { passive: false });

  // DOM
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const kpiApples = document.getElementById('kpi-apples');
  const kpiBest = document.getElementById('kpi-best');
  const restartBtn = document.getElementById('restart');
  const backToSnakeBtn = document.getElementById('backToSnake');
  const overlay = document.getElementById('overlay');
  const selectOverlay = document.getElementById('selectOverlay');
  const startBtn = document.getElementById('startBtn');
  const switchGameBtn = document.getElementById('switchGame');
  const pickSnake = document.getElementById('pickSnake');
  const pickRunner = document.getElementById('pickRunner');

  // Grid
  const size = 50;
  const cols = canvas.width / size;  // 10
  const rows = canvas.height / size; // 9

  // App State
  let mode = 'snake'; // 'snake' | 'runner'
  let best = 0;
  let animReq = null;

  // ===== Snake (continuous smooth) =====
  const cellSpeed = 2.2; // Zellen/Sekunde
  let snake, prevSnake, dir, nextDir, items, alive, score, growPending;
  let progress = 0, lastTime = 0;

  function snakeInit() {
    mode = 'snake';
    backToSnakeBtn.style.display = 'none';
    switchGameBtn.textContent = '‚öôÔ∏è';
    score = 0; growPending = 0; alive = true;
    snake = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }];
    prevSnake = snake.map(s => ({...s}));
    dir = { x: 1, y: 0 }; nextDir = { x: 1, y: 0 };
    items = generateInitialItems(3);
    progress = 0; lastTime = performance.now();
    scoreEl.textContent = 'Score: 0';
    bestEl.textContent = 'Best: ' + best;
    kpiApples.textContent = '0';
    kpiBest.textContent = best.toString();
    startLoop();
  }
  function generateInitialItems(n){ const a=[]; while(a.length<n)a.push(randomItem(a)); return a; }
  function randomItem(existing){
    const type = Math.random() < 0.25 ? 'flag' : 'clock';
    let fx, fy;
    do {
      fx = Math.floor(Math.random()*cols);
      fy = Math.floor(Math.random()*rows);
    } while (
      snake.some(p=>p.x===fx&&p.y===fy) ||
      existing.some(it=>it.x===fx&&it.y===fy) ||
      (items||[]).some(it=>it.x===fx&&it.y===fy)
    );
    return {x:fx,y:fy,type};
  }
  window.addEventListener('keydown', (e)=>{
    if (mode!=='snake'||!alive) return;
    if (e.key==='ArrowUp'   && dir.y===0) nextDir={x:0,y:-1};
    if (e.key==='ArrowDown' && dir.y===0) nextDir={x:0,y: 1};
    if (e.key==='ArrowLeft' && dir.x===0) nextDir={x:-1,y:0};
    if (e.key==='ArrowRight'&& dir.x===0) nextDir={x: 1,y:0};
  });

  function loop(now){
    const dt = (now - lastTime)/1000; lastTime = now;
    if (mode==='snake'){
      progress += dt*cellSpeed;
      while(progress>=1){ stepSnake(); progress-=1; prevSnake = snake.map(s=>({...s})); }
      drawBoard(); drawItems(); drawSnakeInterpolated(progress);
    } else {
      runnerFrame(now, dt);
    }
    animReq = requestAnimationFrame(loop);
  }
  function startLoop(){ cancelAnimationFrame(animReq); animReq = requestAnimationFrame(loop); }

  function stepSnake(){
    if (dir.x !== -nextDir.x || dir.y !== -nextDir.y) dir = nextDir;
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
    if (head.x<0||head.y<0||head.x>=cols||head.y>=rows) return snakeGameOver();
    if (snake.some(p=>p.x===head.x&&p.y===head.y)) return snakeGameOver();

    const body = [head, ...snake];
    const eat = items.findIndex(it=>it.x===head.x&&it.y===head.y);
    if (eat!==-1){
      const it=items[eat];
      if (it.type==='clock'){ score+=1; growPending+=1; }
      else { score+=5; growPending+=5; }
      scoreEl.textContent='Score: '+score;
      kpiApples.textContent=String(score);
      items.splice(eat,1); items.push(randomItem(items));
    }
    if (growPending>0){ growPending--; snake=body; } else { body.pop(); snake=body; }
  }
  function snakeGameOver(){
    alive=false; if (score>best) best=score;
    bestEl.textContent='Best: '+best; kpiBest.textContent=String(best);
    overlay.style.display='flex';
  }

  function drawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#b31322'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.35)';
    for(let x=0;x<=canvas.width;x+=size){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,canvas.height); ctx.stroke(); }
    for(let y=0;y<=canvas.height;y+=size){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(canvas.width,y+0.5); ctx.stroke(); }
    ctx.restore();
  }
  function drawItems(){
    for(const it of items){
      if (it.type==='clock') drawSilverWatch(it.x*size,it.y*size);
      else drawSwissFlag(it.x*size,it.y*size);
    }
  }
  function drawSilverWatch(x,y){
    const cx=x+size/2, cy=y+size/2, r=size*0.42;
    const g=ctx.createRadialGradient(cx-r*0.3,cy-r*0.3,r*0.2,cx,cy,r);
    g.addColorStop(0,'#eee'); g.addColorStop(0.5,'#cfcfcf'); g.addColorStop(1,'#a8a8a8');
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();
    ctx.lineWidth=1.1; ctx.strokeStyle='#7f7f7f'; ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,r*0.72,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
    ctx.lineWidth=0.8; ctx.strokeStyle='#cdcdcd'; ctx.stroke();
    const mr=r*0.9; ctx.strokeStyle='#6b6b6b'; ctx.lineCap='round';
    ctx.lineWidth=1.6; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+mr*0.55,cy-mr*0.2); ctx.stroke();
    ctx.lineWidth=2.0; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+mr*0.35,cy-mr*0.35); ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,1.2,0,Math.PI*2); ctx.fillStyle='#7b7b7b'; ctx.fill();
  }
  function drawSwissFlag(x,y){
    const pad=6, w=size-pad*2, h=size-pad*2, rx=x+pad, ry=y+pad;
    ctx.fillStyle='#e71d2b'; ctx.fillRect(rx,ry,w,h);
    ctx.strokeStyle='#a50f1b'; ctx.lineWidth=1; ctx.strokeRect(rx+0.5,ry+0.5,w-1,h-1);
    ctx.fillStyle='#fff'; const bar=Math.floor(w*0.22), cx=rx+w/2, cy=ry+h/2;
    ctx.fillRect(cx-bar/2, ry+h*0.2, bar, h*0.6);
    ctx.fillRect(rx+w*0.2, cy-bar/2, w*0.6, bar);
  }
  function drawSnakeInterpolated(t){
    ctx.fillStyle='#ff334d';
    for(let i=0;i<snake.length;i++){
      const cur=snake[i], prev=prevSnake[i]||cur;
      const x=(prev.x+(cur.x-prev.x)*t)*size, y=(prev.y+(cur.y-prev.y)*t)*size;
      ctx.fillRect(x,y,size,size);
    }
    // Augen
    const ch=snake[0], ph=prevSnake[0]||ch;
    const hx=(ph.x+(ch.x-ph.x)*t)*size, hy=(ph.y+(ch.y-ph.y)*t)*size, cx=hx+size/2, cy=hy+size/2;
    let ox=0,oy=0; if(dir.x>0)ox=6; if(dir.x<0)ox=-6; if(dir.y>0)oy=6; if(dir.y<0)oy=-6;
    let ex1,ey1,ex2,ey2;
    if (dir.x!==0){ ex1=cx+ox; ey1=cy-7; ex2=cx+ox; ey2=cy+7; }
    else { ex1=cx-7; ey1=cy+oy; ex2=cx+7; ey2=cy+oy; }
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(ex1,ey1,5,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(ex2,ey2,5,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#111';
    const px1=ex1+(ox?Math.sign(ox)*1.6:0), py1=ey1+(oy?Math.sign(oy)*1.6:0);
    const px2=ex2+(ox?Math.sign(ox)*1.6:0), py2=ey2+(oy?Math.sign(oy)*1.6:0);
    ctx.beginPath(); ctx.arc(px1,py1,2.2,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(px2,py2,2.2,0,Math.PI*2); ctx.fill();
  }

  // ===== Runner (Subway-like, + Features) =====
  // Score: +1 pro √ºbersprungenem Hindernis (wenn es am Spieler vorbeigeht)
  // Luft-Uhr: +3 beim Einsammeln
  // Hindernisse: 'spike' | 'robber' | 'barrel'
  // Plattformen: 3‚Äì4s erh√∂hte Ebene
  let r_playerX, r_playerY, r_vy, r_onGround, r_score, r_lastSpawn, r_speed, r_obstacles, r_collects, r_platforms;
  const g = 0.7;
  const groundYBase = canvas.height - 60;
  let groundY = groundYBase;
  let elevatedUntil = 0;

  function runnerInit(){
    mode='runner';
    switchGameBtn.textContent='üéÆ';
    backToSnakeBtn.style.display='inline-block';
    scoreEl.textContent='Score: 0'; r_score=0;
    r_playerX = canvas.width*0.25;
    r_playerY = groundYBase - 36;
    r_vy = 0; r_onGround = true;
    r_speed = 4.2;
    r_lastSpawn = 0;
    r_obstacles=[]; r_collects=[]; r_platforms=[];
    groundY = groundYBase; elevatedUntil = 0;
    lastTime = performance.now();
  }
  window.addEventListener('keydown', (e)=>{
    if (mode!=='runner') return;
    if (e.key==='ArrowUp' || e.key===' ') { if (r_onGround) { r_vy=-12; r_onGround=false; } }
    if (e.key==='ArrowDown'){ r_speed = Math.min(7, r_speed + 0.4); }
    // Links/Rechts optional ‚Äì kleine seitliche Bewegung
    if (e.key==='ArrowLeft'){ r_playerX = Math.max(40, r_playerX - 30); }
    if (e.key==='ArrowRight'){ r_playerX = Math.min(canvas.width-40, r_playerX + 30); }
  });

  function spawnStuff(now){
    // Hindernisse
    if (now - r_lastSpawn > 800){
      const typePool = ['spike','robber','barrel'];
      const type = typePool[Math.floor(Math.random()*typePool.length)];
      const w = type==='robber'? 36 : 30;
      const h = type==='spike'? 30 : 36;
      r_obstacles.push({
        type, x: canvas.width + 40, y: groundY - h, w, h, scored:false
      });
      r_lastSpawn = now;
    }
    // Luft-Uhr
    if (Math.random() < 0.02){
      const y = groundY - 120 - Math.random()*80;
      r_collects.push({ x: canvas.width + 20, y, r: 14 });
    }
    // Plattformen
    if (Math.random() < 0.015){
      const w = 120 + Math.random()*80;
      const y = groundY - (100 + Math.random()*80);
      r_platforms.push({ x: canvas.width + 60, y, w, h: 12, alive:true });
    }
  }

  function drawRunnerBackground(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#b31322'; ctx.fillRect(0,0,canvas.width,canvas.height);
    // dezente Spuren
    for(let i=0;i<3;i++){
      ctx.fillStyle = i%2===0 ? 'rgba(255,255,255,0.06)' : 'rgba(255,255,255,0.1)';
      ctx.fillRect(i*(canvas.width/3),0,canvas.width/3,canvas.height);
    }
    // Boden
    ctx.fillStyle='#8a0e1a'; ctx.fillRect(0, groundY, canvas.width, 4);
  }

  function drawCollect(x,y,r){
    // Luft-Uhr (+3)
    ctx.save();
    const cx=x, cy=y;
    const grad=ctx.createRadialGradient(cx-r*0.3,cy-r*0.3,r*0.2,cx,cy,r);
    grad.addColorStop(0,'#eee'); grad.addColorStop(0.5,'#cfcfcf'); grad.addColorStop(1,'#a8a8a8');
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fillStyle=grad; ctx.fill();
    ctx.lineWidth=1.1; ctx.strokeStyle='#7f7f7f'; ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,r*0.72,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
    ctx.lineWidth=0.8; ctx.strokeStyle='#cdcdcd'; ctx.stroke();
    ctx.restore();
  }

  function drawObstacle(ob){
    if (ob.type==='spike'){
      ctx.fillStyle='#222';
      ctx.beginPath();
      ctx.moveTo(ob.x, ob.y+ob.h);
      ctx.lineTo(ob.x+ob.w/2, ob.y);
      ctx.lineTo(ob.x+ob.w, ob.y+ob.h);
      ctx.closePath(); ctx.fill();
    } else if (ob.type==='robber'){
      // einfacher "R√§uber"
      ctx.fillStyle='#222'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h); // K√∂rper
      ctx.fillStyle='#fff'; ctx.fillRect(ob.x+6, ob.y+6, ob.w-12, 6); // Maske
      ctx.fillStyle='#000'; ctx.fillRect(ob.x+10, ob.y+8, 4, 3);
      ctx.fillRect(ob.x+ob.w-14, ob.y+8, 4, 3);
      ctx.fillStyle='#222'; ctx.fillRect(ob.x+8, ob.y+ob.h-8, ob.w-16, 6); // G√ºrtel
    } else {
      // Fass
      ctx.fillStyle='#6b3e2e'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      ctx.strokeStyle='#3a1f16'; ctx.lineWidth=2; ctx.strokeRect(ob.x+1, ob.y+1, ob.w-2, ob.h-2);
    }
  }

  function drawPlatform(p){
    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.strokeStyle='rgba(0,0,0,0.2)';
    ctx.strokeRect(p.x+0.5, p.y+0.5, p.w-1, p.h-1);
  }

  function drawRunnerBoy(px, py, jumping){
    // einfacher ‚ÄúJunge‚Äù mit Armen/Beinen animiert
    // K√∂rper
    ctx.fillStyle='#ff334d';
    ctx.fillRect(px-14, py-28, 28, 28); // Torso/Kopfblock
    // Kopf-Augen
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(px-6, py-22, 4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(px+6, py-22, 4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(px-5, py-22, 2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(px+7, py-22, 2, 0, Math.PI*2); ctx.fill();
    // Arme/Beine
    ctx.strokeStyle='#ff334d'; ctx.lineWidth=5; ctx.lineCap='round';
    const t = performance.now()/200;
    const swing = jumping ? Math.sin(t)*8 : Math.sin(t)*3;
    // Arme
    ctx.beginPath(); ctx.moveTo(px-14, py-18); ctx.lineTo(px-14 - swing, py-8 - (jumping?6:0)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(px+14, py-18); ctx.lineTo(px+14 + swing, py-8 - (jumping?6:0)); ctx.stroke();
    // Beine
    ctx.beginPath(); ctx.moveTo(px-6, py); ctx.lineTo(px-6 - swing, py+12 + (jumping?6:0)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(px+6, py); ctx.lineTo(px+6 + swing, py+12 + (jumping?6:0)); ctx.stroke();
  }

  function runnerFrame(now, dt){
    // Ablaufzeiten
    if (elevatedUntil>0 && now>elevatedUntil){ elevatedUntil=0; groundY = groundYBase; }
    spawnStuff(now);

    // Physik
    r_playerY += r_vy;
    r_vy += g;
    // Boden / Plattformen
    let onPlat = false, platTop = groundY;
    for (const p of r_platforms){
      // Check Landen von oben
      if (r_playerX>p.x && r_playerX<p.x+p.w){
        if (r_playerY <= p.y && r_playerY + r_vy >= p.y){
          r_playerY = p.y; r_vy = 0; onPlat = true; platTop = p.y;
        }
      }
    }
    if (!onPlat){
      if (r_playerY >= groundY){ r_playerY = groundY; r_vy=0; r_onGround = true; } else { r_onGround=false; }
    } else { r_onGround=true; }

    drawRunnerBackground();

    // Plattformen bewegen/zeichnen
    for (const p of r_platforms){ p.x -= r_speed*0.9; drawPlatform(p); }
    r_platforms = r_platforms.filter(p => p.x + p.w > -10);

    // Collectibles bewegen
    for (const c of r_collects){ c.x -= r_speed; drawCollect(c.x, c.y, c.r); }
    // Einsammeln (+3)
    r_collects = r_collects.filter(c=>{
      const dx = Math.abs(c.x - r_playerX), dy = Math.abs(c.y - r_playerY+18);
      if (dx < 18 && dy < 28){
        r_score += 3; scoreEl.textContent='Score: '+r_score;
        return false;
      }
      return c.x > -20;
    });

    // Hindernisse bewegen/zeichnen
    for (const ob of r_obstacles){
      ob.x -= r_speed;
      drawObstacle(ob);
      // Score +1 wenn passiert
      if (!ob.scored && ob.x + ob.w < r_playerX - 10){
        r_score += 1; ob.scored = true; scoreEl.textContent='Score: '+r_score;
      }
      // Kollision
      const px = r_playerX-14, py = r_playerY-28, pw=28, ph=28;
      const collide = !(px+pw < ob.x || px > ob.x+ob.w || py+ph < ob.y || py > ob.y+ob.h);
      if (collide){
        overlay.style.display='flex'; return;
      }
    }
    r_obstacles = r_obstacles.filter(o => o.x + o.w > -10);

    // Player zeichnen
    drawRunnerBoy(r_playerX, r_playerY, !r_onGround);

    // Auf Plattform-Ebene ‚Äúboosten‚Äù (3‚Äì4s), wenn auf einer speziellen Plattform landet
    // (leicht zuf√§llig: 25% der Plattformen geben Boost)
    for (const p of r_platforms){
      if (p.alive && Math.random()<0.001 && r_playerY===p.y){
        elevatedUntil = performance.now() + (3000 + Math.random()*1000);
        groundY = p.y; p.alive=false;
      }
    }
  }

  // ===== UI Aktionen =====
  startBtn.addEventListener('click', ()=>{
    overlay.style.display='none';
    restartBtn.style.display='inline-block';
    // Wenn zuletzt Snake, Snake fortsetzen, sonst Runner
    if (mode==='snake') snakeInit(); else { runnerInit(); startLoop(); }
  });

  restartBtn.addEventListener('click', ()=>{
    // nur Overlay zeigen, Nutzer startet erneut
    overlay.style.display='flex';
  });

  backToSnakeBtn.addEventListener('click', ()=>{
    overlay.style.display='flex';
    mode='snake'; kpiApples.textContent='0';
    snakeInit();
  });

  switchGameBtn.addEventListener('click', ()=>{
    // Icon wechselt und Spiel auch
    if (mode==='snake'){
      overlay.style.display='none';
      restartBtn.style.display='inline-block';
      runnerInit(); startLoop();
    } else {
      overlay.style.display='none';
      restartBtn.style.display='inline-block';
      snakeInit();
    }
  });

  pickSnake.addEventListener('click', ()=>{
    selectOverlay.style.display='none';
    mode='snake'; overlay.style.display='flex';
    // Karte zeigt Snake-Preview
    snakeInit(); cancelAnimationFrame(animReq); drawBoard(); drawItems(); drawSnakeInterpolated(0);
  });
  pickRunner.addEventListener('click', ()=>{
    selectOverlay.style.display='none';
    mode='runner'; overlay.style.display='flex';
    // Kopfwerte √ºbernehmen
    kpiApples.textContent='0'; kpiBest.textContent=String(best);
    runnerInit(); cancelAnimationFrame(animReq); drawRunnerBackground();
  });

  // Startansicht: Auswahl mit 2 Feldern
  function startScreen(){
    selectOverlay.style.display='flex';
    switchGameBtn.textContent='‚öôÔ∏è';
    scoreEl.textContent='Score: 0'; bestEl.textContent='Best: '+best;
  }
  startScreen();
</script>
</body>
</html>
