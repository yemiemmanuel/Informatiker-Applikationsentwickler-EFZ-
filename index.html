<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>SWATCH Snake & Runner</title>
<style>
  html { scroll-behavior: smooth; }
  body {
    margin: 0; font-family: Arial, sans-serif; color: #111;
    background: linear-gradient(135deg, #ffffff 0%, #fff1f1 45%, #e71d2b 100%);
    min-height: 100vh;
  }
  .corner {
    position: fixed; width: 76px; height: 76px; object-fit: contain;
    opacity: 0.2; pointer-events: none; user-select: none; z-index: 0;
  }
  .corner.tl { top: 10px; left: 10px; }
  .corner.tr { top: 10px; right: 10px; }
  .corner.bl { bottom: 10px; left: 10px; }
  .corner.br { bottom: 10px; right: 10px; }

  .content { position: relative; z-index: 1; }
  .page {
    min-height: 100vh; display: flex; flex-direction: column; align-items: center; gap: 16px;
    padding: 32px 16px 56px;
  }
  .brand {
    display: flex; align-items: center; gap: 12px;
    letter-spacing: 2px; font-weight: 800; font-size: 28px; color: #111;
  }
  .brand .plus { display: inline-block; width: 24px; height: 24px; background: #e71d2b; position: relative; border-radius: 4px; }
  .brand .plus::before, .brand .plus::after {
    content: ""; position: absolute; background: #fff; left: 50%; top: 50%; transform: translate(-50%,-50%);
  }
  .brand .plus::before { width: 70%; height: 22%; }
  .brand .plus::after  { width: 22%; height: 70%; }

  .hud { display: flex; gap: 12px; align-items: center; justify-content: center; flex-wrap: wrap; }
  .btn {
    padding: 12px 18px; border: none; border-radius: 12px; cursor: pointer;
    background: #1a5bd6; color: #fff; font-weight: 700; box-shadow: 0 3px 10px rgba(0,0,0,0.14);
  }
  .btn:hover { filter: brightness(1.06); }
  .btn-secondary { background: #e71d2b; }
  .stat {
    padding: 8px 12px; border-radius: 10px; background: #fff; color: #333;
    box-shadow: 0 1px 4px rgba(0,0,0,0.08); font-weight: 700; min-width: 110px; text-align: center;
  }

  .frame {
    background: #b31322; border: 8px solid #8a0e1a; border-radius: 16px;
    box-shadow: 0 12px 30px rgba(0,0,0,0.2), inset 0 0 0 1px rgba(255,255,255,0.2);
    position: relative;
  }
  canvas { display: block; touch-action: none; border-radius: 10px; }

  .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; backdrop-filter: blur(2px); padding: 16px; }
  .card {
    width: 360px; border-radius: 18px; overflow: hidden; box-shadow: 0 18px 40px rgba(0,0,0,0.28);
    background: #ffffff; display: grid; grid-template-rows: auto 84px auto; border: 1px solid rgba(0,0,0,0.06);
  }
  .card-head {
    background: #51c5ff; color: #fff; padding: 18px 20px 12px;
    display: grid; grid-template-columns: 1fr 1fr; align-items: center; text-align: center; gap: 12px;
  }
  .kpi { font-size: 16px; font-weight: 700; display: grid; gap: 4px; justify-items: center; }
  .kpi .icon { font-size: 28px; line-height: 1; }
  .kpi .val { font-size: 22px; }
  .card-mid { background: #73d1ff; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 8px; position: relative; }
  .snake-preview { width: 280px; height: 36px; background: #ff334d; border-radius: 18px; position: relative; }
  .snake-preview .eye { position: absolute; top: -10px; width: 16px; height: 16px; border-radius: 50%; background: #fff; border: 2px solid #1f1f1f; }
  .snake-preview .eye.left  { left: 210px; }
  .snake-preview .eye.right { left: 232px; }
  .snake-preview .pupil { position: absolute; width: 6px; height: 6px; border-radius: 50%; background: #111; top: 4px; left: 4px; }

  .card-foot { background: repeating-linear-gradient(90deg, #b8d97b 0 24px, #a7cf64 24px 48px); padding: 16px; }
  .card-actions { padding: 16px; display: flex; gap: 12px; justify-content: center; background: #ffffff; }
  .btn-play {
    background: #1a5bd6; color: #fff; font-weight: 800; border: none; border-radius: 12px; padding: 12px 24px; font-size: 16px;
    display: inline-flex; align-items: center; gap: 8px; cursor: pointer; box-shadow: 0 6px 16px rgba(26,91,214,0.35);
  }

  .overlay-select { display: none; position: absolute; inset: 0; align-items: center; justify-content: center; padding: 16px; backdrop-filter: blur(2px); }
  .select-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; }
  .pick {
    width: 280px; border-radius: 18px; overflow: hidden; border: 1px solid rgba(0,0,0,0.06);
    background: #fff; box-shadow: 0 12px 32px rgba(0,0,0,0.2); cursor: pointer;
    display: grid; grid-template-rows: 140px auto;
  }
  .pick .head { display: flex; align-items: center; justify-content: center; font-weight: 800; color: #fff; font-size: 18px; }
  .pick.snake .head { background: #ff6b8a; }
  .pick.runner .head { background: #1a5bd6; }
  .pick .body { padding: 14px; text-align: center; color: #333; }
</style>
</head>
<body>
  <img class="corner tl" src="swatch-logo.png" alt="Logo">
  <img class="corner tr" src="swatch-logo.png" alt="Logo">
  <img class="corner bl" src="swatch-logo.png" alt="Logo">
  <img class="corner br" src="swatch-logo.png" alt="Logo">

  <div class="content page">
    <div class="brand">SWATCH <span class="plus"></span></div>

    <div class="hud">
      <button id="switchGame" class="btn" title="Spiel w√§hlen">üéÆ</button>
      <button id="restart" class="btn" style="display:none;">Neu starten</button>
      <button id="backToSnake" class="btn btn-secondary" style="display:none;">Zur√ºck zu Snake</button>
      <div class="stat" id="score">Score: 0</div>
      <div class="stat" id="best">Best: 0</div>
    </div>

    <div class="frame">
      <canvas id="board" width="500" height="450" aria-label="Spielfeld"></canvas>

      <div id="overlay" class="overlay">
        <div class="card">
          <div class="card-head">
            <div class="kpi">
              <div class="icon">‚åöÔ∏è</div>
              <div>Uhren</div>
              <div class="val" id="kpi-apples">0</div>
            </div>
            <div class="kpi">
              <div class="icon">üèÜ</div>
              <div>Best</div>
              <div class="val" id="kpi-best">0</div>
            </div>
          </div>
          <div class="card-mid">
            <div class="snake-preview">
              <div class="eye left"><div class="pupil"></div></div>
              <div class="eye right"><div class="pupil"></div></div>
            </div>
          </div>
          <div class="card-foot"></div>
          <div class="card-actions">
            <button id="startBtn" class="btn-play">‚ñ∂ Play</button>
          </div>
        </div>
      </div>

      <div id="selectOverlay" class="overlay-select">
        <div class="select-grid">
          <div id="pickSnake" class="pick snake">
            <div class="head">SWATCH Snake</div>
            <div class="body">Rote Schlange mit Farbverlauf, Uhren & Flaggen.</div>
          </div>
          <div id="pickRunner" class="pick runner">
            <div class="head">SWATCH Runner</div>
            <div class="body">Hindernisse √ºberspringen, Uhren sammeln.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
  // Pfeiltasten blockieren Scroll
  window.addEventListener('keydown', (e) => {
    const block = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '];
    if (block.includes(e.key)) e.preventDefault();
  }, { passive: false });

  // DOM
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const kpiApples = document.getElementById('kpi-apples');
  const kpiBest = document.getElementById('kpi-best');
  const restartBtn = document.getElementById('restart');
  const backToSnakeBtn = document.getElementById('backToSnake');
  const overlay = document.getElementById('overlay');
  const selectOverlay = document.getElementById('selectOverlay');
  const startBtn = document.getElementById('startBtn');
  const switchGameBtn = document.getElementById('switchGame');
  const pickSnake = document.getElementById('pickSnake');
  const pickRunner = document.getElementById('pickRunner');

  // Grid
  const size = 50;
  const cols = canvas.width / size;  // 10
  const rows = canvas.height / size; // 9

  // App State
  let mode = 'snake';
  let best = 0;
  let animReq = null;
  let lastTime = 0;

  // ========= Snake: schneller + Farbverlauf + Mund =========
  const cellSpeed = 3.2; // Zellen/Sekunde (h√∂her = schneller)
  let snake, prevSnake, dir, nextDir, items, alive, score, growPending, progress;

  const colorHead = '#ff334d';   // helles Rot am Kopf
  const colorTail = '#2b0006';   // sehr dunkles Rot am Schwanz

  function lerp(a,b,t){ return a + (b - a) * t; }
  function hexToRgb(h){ const n=parseInt(h.slice(1),16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
  function rgbToHex(r,g,b){ return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }
  function lerpColor(h1,h2,t){
    const a=hexToRgb(h1), b=hexToRgb(h2);
    return rgbToHex(
      Math.round(lerp(a.r,b.r,t)),
      Math.round(lerp(a.g,b.g,t)),
      Math.round(lerp(a.b,b.b,t))
    );
  }

  function snakeInit() {
    mode = 'snake';
    backToSnakeBtn.style.display = 'none';
    switchGameBtn.textContent = 'üéÆ';
    score = 0; growPending = 0; alive = true;
    snake = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }];
    prevSnake = snake.map(s => ({...s}));
    dir = { x: 1, y: 0 }; nextDir = { x: 1, y: 0 };
    items = snakeGenerateInitialItems(3);
    progress = 0; lastTime = performance.now();
    scoreEl.textContent = 'Score: 0';
    bestEl.textContent = 'Best: ' + best;
    kpiApples.textContent = '0';
    kpiBest.textContent = best.toString();
  }
  function snakeGenerateInitialItems(n){ const a=[]; while(a.length<n)a.push(snakeRandomItem(a)); return a; }
  function snakeRandomItem(existing){
    const type = Math.random() < 0.25 ? 'flag' : 'clock';
    let fx, fy;
    do {
      fx = Math.floor(Math.random()*cols);
      fy = Math.floor(Math.random()*rows);
    } while (
      snake.some(p=>p.x===fx&&p.y===fy) ||
      existing.some(it=>it.x===fx&&it.y===fy) ||
      (items||[]).some(it=>it.x===fx&&it.y===fy)
    );
    return {x:fx,y:fy,type};
  }

  window.addEventListener('keydown', (e)=>{
    if (mode!=='snake'||!alive) return;
    if (e.key==='ArrowUp'   && dir.y===0) nextDir={x:0,y:-1};
    if (e.key==='ArrowDown' && dir.y===0) nextDir={x:0,y: 1};
    if (e.key==='ArrowLeft' && dir.x===0) nextDir={x:-1,y:0};
    if (e.key==='ArrowRight'&& dir.x===0) nextDir={x: 1,y:0};
  });

  function snakeStep(){
    if (dir.x !== -nextDir.x || dir.y !== -nextDir.y) dir = nextDir;
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
    if (head.x<0||head.y<0||head.x>=cols||head.y>=rows) return snakeGameOver();
    if (snake.some(p=>p.x===head.x&&p.y===head.y)) return snakeGameOver();
    const body=[head,...snake];
    const eat = items.findIndex(it=>it.x===head.x&&it.y===head.y);
    if (eat!==-1){
      const it=items[eat];
      if (it.type==='clock'){ score+=1; growPending+=1; }
      else { score+=5; growPending+=5; }
      scoreEl.textContent='Score: '+score; kpiApples.textContent=String(score);
      items.splice(eat,1); items.push(snakeRandomItem(items));
    }
    if (growPending>0){ growPending--; snake=body; } else { body.pop(); snake=body; }
  }
  function snakeGameOver(){
    alive=false; if (score>best) best=score;
    bestEl.textContent='Best: '+best; kpiBest.textContent=String(best);
    overlay.style.display='flex';
  }

  function snakeDrawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#b31322'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.35)';
    for(let x=0;x<=canvas.width;x+=size){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,canvas.height); ctx.stroke(); }
    for(let y=0;y<=canvas.height;y+=size){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(canvas.width,y+0.5); ctx.stroke(); }
    ctx.restore();
  }
  function drawSilverWatch(x,y){
    const cx=x+size/2, cy=y+size/2, r=size*0.42;
    const g=ctx.createRadialGradient(cx-r*0.3,cy-r*0.3,r*0.2,cx,cy,r);
    g.addColorStop(0,'#eee'); g.addColorStop(0.5,'#cfcfcf'); g.addColorStop(1,'#a8a8a8');
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();
    ctx.lineWidth=1.1; ctx.strokeStyle='#7f7f7f'; ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,r*0.72,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
    ctx.lineWidth=0.8; ctx.strokeStyle='#cdcdcd'; ctx.stroke();
    const mr=r*0.9; ctx.strokeStyle='#6b6b6b'; ctx.lineCap='round';
    ctx.lineWidth=1.6; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+mr*0.55,cy-mr*0.2); ctx.stroke();
    ctx.lineWidth=2.0; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+mr*0.35,cy-mr*0.35); ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,1.2,0,Math.PI*2); ctx.fillStyle='#7b7b7b'; ctx.fill();
  }
  function drawSwissFlag(x,y){
    const pad=6, w=size-pad*2, h=size-pad*2, rx=x+pad, ry=y+pad;
    ctx.fillStyle='#e71d2b'; ctx.fillRect(rx,ry,w,h);
    ctx.strokeStyle='#a50f1b'; ctx.lineWidth=1; ctx.strokeRect(rx+0.5,ry+0.5,w-1,h-1);
    ctx.fillStyle='#fff'; const bar=Math.floor(w*0.22), cx=rx+w/2, cy=ry+h/2;
    ctx.fillRect(cx-bar/2, ry+h*0.2, bar, h*0.6);
    ctx.fillRect(rx+w*0.2, cy-bar/2, w*0.6, bar);
  }
  function snakeDrawItems(){
    for(const it of items){
      const x=it.x*size, y=it.y*size;
      (it.type==='clock'?drawSilverWatch:drawSwissFlag)(x,y);
    }
  }

  // Mundfaktor: je n√§her Kopf (interpoliert) an Item, desto gr√∂√üer √ñffnung
  function computeMouthFactor(headPx, headPy){
    let nearest = Infinity;
    for (const it of items){
      const cx = it.x*size + size/2;
      const cy = it.y*size + size/2;
      const dx = headPx - cx, dy = headPy - cy;
      const d = Math.hypot(dx,dy);
      if (d < nearest) nearest = d;
    }
    const openDist = size * 1.2; // ab hier beginnt das √ñffnen
    const f = Math.max(0, Math.min(1, (openDist - nearest) / openDist));
    return f; // 0..1
  }

  function drawSnakeInterpolated(t){
    const n = snake.length || 1;

    // K√∂rper mit Farbverlauf
    for(let i=0;i<snake.length;i++){
      const c=snake[i], p=prevSnake[i]||c;
      const x=(p.x+(c.x-p.x)*t)*size, y=(p.y+(c.y-p.y)*t)*size;
      const ratio = n === 1 ? 0 : i/(n-1);              // 0 (Kopf) ‚Üí 1 (Schwanz)
      ctx.fillStyle = lerpColor(colorHead, colorTail, ratio);
      ctx.fillRect(x,y,size,size);
    }

    // Kopf-Zentrum
    const ch=snake[0], ph=prevSnake[0]||ch;
    const hx=(ph.x+(ch.x-ph.x)*t)*size, hy=(ph.y+(ch.y-ph.y)*t)*size;
    const cx = hx + size/2, cy = hy + size/2;

    // Augen wie gehabt
    let ox=0,oy=0; if(dir.x>0)ox=6; if(dir.x<0)ox=-6; if(dir.y>0)oy=6; if(dir.y<0)oy=-6;
    let ex1,ey1,ex2,ey2;
    if (dir.x!==0){ ex1=cx+ox; ey1=cy-7; ex2=cx+ox; ey2=cy+7; }
    else { ex1=cx-7; ey1=cy+oy; ex2=cx+7; ey2=cy+oy; }
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(ex1,ey1,5,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(ex2,ey2,5,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#111';
    const px1=ex1+(ox?Math.sign(ox)*1.6:0), py1=ey1+(oy?Math.sign(oy)*1.6:0);
    const px2=ex2+(ox?Math.sign(ox)*1.6:0), py2=ey2+(oy?Math.sign(oy)*1.6:0);
    ctx.beginPath(); ctx.arc(px1,py1,2.2,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(px2,py2,2.2,0,Math.PI*2); ctx.fill();

    // Mund (Dreiecks-"Maul" vorn, √∂ffnet bei Ann√§herung)
    const mouthFactor = computeMouthFactor(cx, cy);   // 0..1
    const ux = Math.sign(dir.x), uy = Math.sign(dir.y); // Richtungsvektor in Zellschritten
    const vx = ux !== 0 ? ux : 0;                      // x-Komponente
    const vy = uy !== 0 ? uy : 0;                      // y-Komponente
    const frontX = cx + (vx || 0) * size*0.46 + (vy ? 0 : 0);
    const frontY = cy + (vy || 0) * size*0.46 + (vx ? 0 : 0);
    // senkrechter Vektor f√ºr die Maulbreite
    const pxv = -vy, pyv = vx;
    const widthBase = size*0.18;
    const width = widthBase * (1 + mouthFactor*0.9);   // √∂ffnet bis ~doppelt so breit
    const midX = cx + (vx||0)*size*0.28 + (vy?0:0);
    const midY = cy + (vy||0)*size*0.28 + (vx?0:0);
    const leftX  = midX + pxv*width;
    const leftY  = midY + pyv*width;
    const rightX = midX - pxv*width;
    const rightY = midY - pyv*width;

    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.moveTo(frontX, frontY);
    ctx.lineTo(leftX, leftY);
    ctx.lineTo(rightX, rightY);
    ctx.closePath();
    ctx.fill();
  }

  // ========= Runner (unver√§ndert aus deiner letzten Version mit Anpassungen) =========
  const RUNNER_PLATFORM_MAX = 4;
  const RUNNER_PLATFORM_SPAWN_P = 0.015;
  const RUNNER_LEAF_SPAWN_P = 0.012;
  const RUNNER_DOUBLE_ROBBER_P = 0.12;

  let r_playerX, r_playerY, r_vy, r_onGround, r_score, r_lastSpawn, r_speed, r_obstacles, r_collects, r_platforms;
  const grav = 0.7;
  const groundBase = canvas.height - 60;
  let groundY = groundBase;

  const runnerImg = new Image();
  runnerImg.src = 'runner-boy.png';
  let runnerImgLoaded = false;
  runnerImg.onload = () => runnerImgLoaded = true;

  function runnerInit(){
    mode='runner';
    switchGameBtn.textContent='‚öôÔ∏è';
    backToSnakeBtn.style.display='inline-block';
    r_score=0; scoreEl.textContent='Score: 0';
    r_playerX = canvas.width*0.25;
    r_playerY = groundBase - 10;
    r_vy=0; r_onGround=true;
    r_speed=4.2; r_lastSpawn=performance.now();
    r_obstacles=[]; r_collects=[]; r_platforms=[];
    groundY = groundBase;
  }
  window.addEventListener('keydown', (e)=>{
    if (mode!=='runner') return;
    if (e.key==='ArrowUp' || e.key===' ') { if (r_onGround) { r_vy=-12; r_onGround=false; } }
    if (e.key==='ArrowDown'){ r_speed = Math.min(7, r_speed + 0.4); }
    if (e.key==='ArrowLeft'){  r_playerX = Math.max(40, r_playerX - 28); }
    if (e.key==='ArrowRight'){ r_playerX = Math.min(canvas.width-40, r_playerX + 28); }
  });
  function drawPlatform(p){
    if (p.type === 'leaf') {
      const cx = p.x + p.w/2, cy = p.y + p.h/2;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(p.w/60, p.h/12);
      ctx.beginPath();
      ctx.fillStyle = 'rgba(120, 200, 90, 0.9)';
      ctx.moveTo(0, -6);
      ctx.bezierCurveTo(18, -6, 18, 6, 0, 6);
      ctx.bezierCurveTo(-18, 6, -18, -6, 0, -6);
      ctx.fill();
      ctx.strokeStyle = 'rgba(60, 120, 50, 0.9)';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(0, 6); ctx.stroke();
      ctx.restore();
    } else {
      ctx.fillStyle='rgba(255,255,255,0.75)';
      ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.strokeStyle='rgba(0,0,0,0.2)';
      ctx.strokeRect(p.x+0.5, p.y+0.5, p.w-1, p.h-1);
    }
  }
  function spawnRunnerStuff(now){
    if (now - r_lastSpawn > 800){
      if (Math.random() < RUNNER_DOUBLE_ROBBER_P) {
        const gap = 24;
        const w = 40, h = 36;
        const baseX = canvas.width + 60;
        r_obstacles.push({ type:'robber', x: baseX,         y: groundY - h, w, h, scored:false });
        r_obstacles.push({ type:'robber', x: baseX + w+gap, y: groundY - h, w, h, scored:false });
        const leafW = 70, leafH = 12;
        const leafX = baseX - 110;
        const leafY = groundY - (32 + Math.random()*12);
        r_platforms.push({ type:'leaf', x: leafX, y: leafY, w: leafW, h: leafH });
        r_lastSpawn = now;
      } else {
        const typePool=['spike','robber','barrel'];
        const type = typePool[Math.floor(Math.random()*typePool.length)];
        const w = type==='robber'? 40 : 34;
        const h = type==='spike'? 28 : 36;
        r_obstacles.push({ type, x: canvas.width + 50, y: groundY - h, w, h, scored:false });
        r_lastSpawn = now;
      }
    }
    if (Math.random() < 0.02){
      const y = groundY - (80 + Math.random()*70);
      r_collects.push({ x: canvas.width + 30, y, r: 14 });
    }
    if (r_platforms.length < RUNNER_PLATFORM_MAX) {
      if (Math.random() < RUNNER_LEAF_SPAWN_P) {
        const w = 70 + Math.random()*20, h = 12;
        const y = groundY - (26 + Math.random()*12);
        r_platforms.push({ type:'leaf', x: canvas.width + 80, y, w, h });
      }
      if (Math.random() < RUNNER_PLATFORM_SPAWN_P) {
        const single = Math.random() < 0.6;
        if (single) {
          const w = 110 + Math.random()*80, h = 12;
          const y = groundY - (34 + Math.random()*16);
          r_platforms.push({ type:'plat', x: canvas.width + 100, y, w, h });
        } else {
          const baseY = groundY - (36 + Math.random()*14);
          const stepW = 80, h = 12;
          r_platforms.push({ type:'plat', x: canvas.width + 100,          y: baseY,     w: stepW, h });
          r_platforms.push({ type:'plat', x: canvas.width + 100 + stepW,  y: baseY-14,  w: stepW, h });
        }
      }
    }
  }
  function drawRunnerBG(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#b31322'; ctx.fillRect(0,0,canvas.width,canvas.height);
    for(let i=0;i<3;i++){
      ctx.fillStyle = i%2===0 ? 'rgba(255,255,255,0.06)' : 'rgba(255,255,255,0.1)';
      ctx.fillRect(i*(canvas.width/3), 0, canvas.width/3, canvas.height);
    }
    ctx.fillStyle='#8a0e1a'; ctx.fillRect(0, groundY, canvas.width, 4);
  }
  function drawCollect(x,y,r){
    const cx=x, cy=y; const g=ctx.createRadialGradient(cx-r*0.3,cy-r*0.3,r*0.2,cx,cy,r);
    g.addColorStop(0,'#eee'); g.addColorStop(0.5,'#cfcfcf'); g.addColorStop(1,'#a8a8a8');
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();
    ctx.lineWidth=1.1; ctx.strokeStyle='#7f7f7f'; ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,r*0.72,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
    ctx.lineWidth=0.8; ctx.strokeStyle='#cdcdcd'; ctx.stroke();
  }
  function drawObstacle(ob){
    if (ob.type==='spike'){
      ctx.fillStyle='#222'; ctx.beginPath();
      ctx.moveTo(ob.x, ob.y+ob.h); ctx.lineTo(ob.x+ob.w/2, ob.y); ctx.lineTo(ob.x+ob.w, ob.y+ob.h);
      ctx.closePath(); ctx.fill();
    } else if (ob.type==='robber'){
      ctx.fillStyle='#222'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      ctx.fillStyle='#fff'; ctx.fillRect(ob.x+6, ob.y+6, ob.w-12, 6);
      ctx.fillStyle='#000'; ctx.fillRect(ob.x+10, ob.y+8, 4, 3); ctx.fillRect(ob.x+ob.w-14, ob.y+8, 4, 3);
      ctx.fillStyle='#222'; ctx.fillRect(ob.x+8, ob.y+ob.h-8, ob.w-16, 6);
    } else {
      ctx.fillStyle='#6b3e2e'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      ctx.strokeStyle='#3a1f16'; ctx.lineWidth=2; ctx.strokeRect(ob.x+1, ob.y+1, ob.w-2, ob.h-2);
    }
  }
  function drawRunnerBoy(px, py, jumping){
    const w=64, h=96;
    const drawX = px - w/2;
    const drawY = py - h + 6;
    if (runnerImgLoaded){
      const bob = jumping ? -4 : Math.sin(performance.now()/200)*1.5;
      ctx.drawImage(runnerImg, drawX, drawY + bob, w, h);
    } else {
      ctx.fillStyle='#ff334d'; ctx.fillRect(px-14, py-28, 28, 28);
      ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(px-6, py-22, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+6, py-22, 4, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(px-5, py-22, 2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+7, py-22, 2, 0, Math.PI*2); ctx.fill();
    }
  }
  function runnerTick(now){
    spawnRunnerStuff(now);
    r_playerY += r_vy;
    r_vy += grav;

    for (const p of r_platforms){ p.x -= r_speed*0.9; drawPlatform(p); }
    r_platforms = r_platforms.filter(p => p.x + p.w > -20);
    if (r_platforms.length > RUNNER_PLATFORM_MAX) r_platforms.length = RUNNER_PLATFORM_MAX;

    let onPlat=false;
    for (const p of r_platforms){
      const withinX = (r_playerX > p.x && r_playerX < p.x + p.w);
      const comingDown = r_vy >= 0;
      const feetY = r_playerY;
      if (withinX && comingDown && feetY >= p.y - 12 && feetY <= p.y + 8) {
        r_playerY = p.y; r_vy = 0; r_onGround = true; onPlat = true; break;
      }
    }
    if (!onPlat){
      if (r_playerY >= groundY){ r_playerY = groundY; r_vy = 0; r_onGround = true; }
      else r_onGround = false;
    }

    drawRunnerBG();

    for (const c of r_collects) c.x -= r_speed;
    for (const c of r_collects) drawCollect(c.x, c.y, c.r);
    r_collects = r_collects.filter(c=>{
      const dx=Math.abs(c.x - r_playerX), dy=Math.abs(c.y - (r_playerY - 40));
      if (dx<24 && dy<40){ r_score+=3; scoreEl.textContent='Score: '+r_score; return false; }
      return c.x > -30;
    });

    for (const ob of r_obstacles){
      ob.x -= r_speed; drawObstacle(ob);
      if (!ob.scored && ob.x + ob.w < r_playerX - 10){ ob.scored = true; r_score += 1; scoreEl.textContent = 'Score: ' + r_score; }
      const px = r_playerX - 24, py = r_playerY - 84, pw = 48, ph = 84;
      const hit = !(px+pw < ob.x || px > ob.x+ob.w || py+ph < ob.y || py > ob.y+ob.h);
      if (hit){ overlay.style.display='flex'; return; }
    }
    r_obstacles = r_obstacles.filter(o => o.x + o.w > -30);

    drawRunnerBoy(r_playerX, r_playerY, !r_onGround);
  }

  // ========= Loop & UI =========
  function startLoop(){ cancelAnimationFrame(animReq); lastTime = performance.now(); animReq = requestAnimationFrame(loop); }
  function loop(now){
    const dt = Math.max(0.001, (now - lastTime)/1000); lastTime = now;
    if (mode==='snake'){
      progress += dt * cellSpeed;
      while (progress >= 1 && alive) { snakeStep(); progress -= 1; prevSnake = snake.map(s=>({...s})); }
      snakeDrawBoard(); snakeDrawItems(); if (alive) drawSnakeInterpolated(progress);
    } else {
      drawRunnerBG(); runnerTick(now);
    }
    animReq = requestAnimationFrame(loop);
  }

  startBtn.addEventListener('click', ()=>{
    overlay.style.display='none';
    restartBtn.style.display='inline-block';
    cancelAnimationFrame(animReq); startLoop();
  });
  restartBtn.addEventListener('click', ()=>{
    cancelAnimationFrame(animReq);
    overlay.style.display='none';
    selectOverlay.style.display='flex';
    scoreEl.textContent='Score: 0';
  });
  backToSnakeBtn.addEventListener('click', ()=>{
    cancelAnimationFrame(animReq);
    overlay.style.display='flex';
    snakeInit(); snakeDrawBoard(); snakeDrawItems(); drawSnakeInterpolated(0);
  });
  switchGameBtn.addEventListener('click', ()=>{
    cancelAnimationFrame(animReq);
    overlay.style.display='none';
    selectOverlay.style.display='flex';
  });
  pickSnake.addEventListener('click', ()=>{
    selectOverlay.style.display='none'; overlay.style.display='flex';
    snakeInit(); snakeDrawBoard(); snakeDrawItems(); drawSnakeInterpolated(0);
  });
  pickRunner.addEventListener('click', ()=>{
    selectOverlay.style.display='none'; overlay.style.display='flex';
    runnerInit(); drawRunnerBG();
  });

  function startScreen(){
    selectOverlay.style.display='flex';
    switchGameBtn.textContent='üéÆ';
    scoreEl.textContent='Score: 0'; bestEl.textContent='Best: '+best;
    snakeInit(); // Preview
    cancelAnimationFrame(animReq); snakeDrawBoard(); snakeDrawItems(); drawSnakeInterpolated(0);
  }
  startScreen();
</script>
</body>
</html>
